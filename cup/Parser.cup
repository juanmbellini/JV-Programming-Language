package atlc;

import java_cup.runtime.*;
import atlc.ast.*;
parser code {:

	public void syntax_error(Symbol s) {
		System.err.println("Syntax error at " + s);
    }

    public static void main(String args[]) throws Exception {
        ComplexSymbolFactory symbolFactory = new ComplexSymbolFactory();
		new Parser(new Scanner(new java.io.FileReader(args[0]), symbolFactory), symbolFactory).debug_parse();
    }
:}


// Main and Return
terminal MAIN;
terminal RETURN;

// Code Structure
terminal String EOL;
terminal String TAB;
terminal String SPACE;

// Types
terminal TYPE_INT;
terminal TYPE_BOOL;
terminal TYPE_STR;

// Var Names
terminal VAR_NAME;

// Literals
terminal Integer LIT_INT;
terminal Boolean LIT_BOOL;
terminal String  LIT_STR;


// IO
terminal READ;
terminal WRITE;

// Conditionals
terminal IF;
terminal ELSE;

// Looping
terminal DO;
terminal WHILE;

// Miscs
terminal LPAREN;
terminal RPAREN;

// Operators
terminal PLUS;
terminal TIMES;
terminal MINUS;
terminal DIVIDE;
terminal EQ;
terminal NEQ;
terminal GT;
terminal LT;
terminal LE;
terminal GE;
terminal NOT;
terminal OR;
terminal AND;
terminal ASSIGN;



// NON TERMINALS

non terminal S;
non terminal BLOCK;
non terminal LINE;
non terminal INSTRUCTION;
non terminal DECL;
non terminal DECL_ASS;
non terminal ASS;
non terminal COMMAND;
non terminal WHILE_B;
non terminal IF_B;
non terminal ELSE_B;

non terminal VALUE;
non terminal EXPR;
non terminal BOOL_EXP;
non terminal INT_EXP;
non terminal INT_VALUE;
non terminal BOOL_VALUE;
non terminal COMP;

non terminal LAMBDA;

// non terminal COMMENT;
// non terminal BLOCK_IF_ELSIF;
// non terminal BLOCK_IF_ELSIF_ELSE;

precedence right EOL;	// Inserted by Eclipse plugin
precedence nonassoc ELSE;	// Inserted by Eclipse plugin
precedence nonassoc WHILE;	// Inserted by Eclipse plugin
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQ, NEQ;
precedence left GT, LT, GE, LE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left RPAREN, LPAREN;
precedence left VAR_NAME;

// ESTRUCTURA
start with S;

S
	::= MAIN BLOCK EOL;


BLOCK
	::= EOL LINE BLOCK | EOL LINE
;

// LINE ::= TAB LINE | INSTRUCTION COMMENT | COMMENT; < EstÃ¡ mal comment
LINE 
	::= TAB LINE
	| INSTRUCTION
;

INSTRUCTION
	::= DECL
	| DECL_ASS
	| ASS
	| COMMAND
    | WHILE_B
    | IF_B
    | RETURN
;

// COMMENT ::= ~ comment;


DECL
    ::= TYPE_INT VAR_NAME
    | TYPE_BOOL VAR_NAME
    | TYPE_STR VAR_NAME
;

DECL_ASS
    ::= DECL ASSIGN SPACE VALUE
;

ASS
    ::= VAR_NAME ASSIGN SPACE VALUE
;

VALUE
    ::= LIT_STR
    | EXPR
;

EXPR
    ::= BOOL_EXP
    | INT_EXP 
;


BOOL_EXP
    ::= BOOL_EXP OR BOOL_EXP
    | BOOL_EXP AND BOOL_EXP
    | NOT BOOL_EXP
    | LPAREN BOOL_EXP RPAREN
    | BOOL_VALUE
;

BOOL_VALUE
    ::= LIT_BOOL | COMP //| VAR_NAME
;

INT_EXP
    ::= INT_EXP PLUS INT_EXP
    | INT_EXP MINUS INT_EXP
    | INT_EXP TIMES INT_EXP
    | INT_EXP DIVIDE INT_EXP
    | LPAREN INT_EXP RPAREN
    | MINUS INT_EXP
    | INT_VALUE 
;

INT_VALUE
    ::= LIT_INT //| VAR_NAME
;

COMP
    ::= INT_EXP SPACE LT SPACE INT_EXP
    | INT_EXP SPACE GT SPACE INT_EXP
    | INT_EXP SPACE LE SPACE INT_EXP
    | INT_EXP SPACE GE SPACE INT_EXP
    | INT_EXP SPACE EQ SPACE INT_EXP
    | INT_EXP SPACE NEQ SPACE INT_EXP
;

COMMAND
    ::= READ VAR_NAME
    | WRITE SPACE VALUE
;

WHILE_B
    ::= WHILE SPACE LPAREN BOOL_EXP RPAREN BLOCK
    | DO BLOCK WHILE SPACE LPAREN BOOL_EXP RPAREN
;

IF_B
    ::= IF SPACE LPAREN BOOL_EXP RPAREN BLOCK ELSE_B
;

ELSE_B
    ::= ELSE BLOCK
    | LAMBDA
;

LAMBDA
    ::= // Empty Production
;




