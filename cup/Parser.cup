package atlc;

import java_cup.runtime.*;
import atlc.nodes.*;
import org.objectweb.asm.tree.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.List;
import java.util.ArrayList;

parser code {:
	public static final Logger l = Logger.getLogger("PARSER");

	public Parser(Scanner scanner, SymbolFactory factory, String className) {
		this(scanner, factory);
	}

	public void syntax_error(Symbol s) {
		System.err.println("Syntax error at " + s);
	}
:}

terminal FUNC, RET; // Functions
terminal SP, INDENT, DEDENT, EOL; // Whitespace
terminal TYPE;
terminal VAR_NAME;
terminal READ_LINE, WRITE_LINE, WRITE; // IO
terminal LPAREN, RPAREN, COMMA;

// Literals
terminal Integer LIT_INT;
terminal Boolean LIT_BOOL;
terminal String  LIT_STR;

terminal IF, ELSE;
terminal DO, WHILE;

terminal ARITHMETIC_OPERATOR;
terminal BOOLEAN_OPERATOR, LOGIC_OPERATOR, UNARY_LOGIC_OPERATOR;
terminal ASSIGN, ASSIGN_TYPE;

non terminal  program;
non terminal List<MethodNode> method_list;
non terminal MethodNode method;
non terminal param_list;
non terminal InsnList stmt_list;
non terminal InsnList stmt;
non terminal method_argument;
non terminal stmt_def_maybe_assign, stmt_assign;
non terminal stmt_if_maybe_else, stmt_if;
non terminal stmt_while;
non terminal InsnList stmt_io;
non terminal stmt_exit, stmt_method_call;
non terminal InsnList expr;
non terminal InsnList expr_bool;
non terminal InsnList expr_int;
non terminal InsnList expr_str;
non terminal method_argument_list;
non terminal block;

precedence left ELSE;
precedence left SP; // TODO: CHECK IF OK
precedence left LPAREN;


// ESTRUCTURA
start with program;

program
	::= method_list:ml stmt_list:sl
		{:
			RESULT = ProgramFactory.create("Hello_world", ml, sl);
			Parser.l.log(Level.INFO, "stmt_list -> PARSE COMPLETE!");
		:}
;

method_list
	::= method:m method_list:ml
		{:
			ml.add(m);
			RESULT = ml;
			Parser.l.log(Level.INFO, "method method_list -> method_list");
		:}
	| // empty
		{:
			RESULT = new ArrayList<MethodNode>();
			Parser.l.log(Level.INFO, "lambda -> method_list");
		:}
;

method
	::= FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list block
		{:
			Parser.l.log(Level.INFO, "FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list block -> method");
		:}
	| FUNC SP VAR_NAME param_list block
		{:
			Parser.l.log(Level.INFO, "FUNC SP VAR_NAME param_list block -> method");
		:}
;

param_list
	::= SP TYPE ASSIGN_TYPE VAR_NAME param_list
		{:
			Parser.l.log(Level.INFO, "SP TYPE ASSIGN_TYPE VAR_NAME param_list -> param_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> param_list");
		:}
;

stmt_list
	::= stmt:s stmt_list:sl
		{:
			Parser.l.log(Level.INFO, "stmt stmt_list -> stmt_list ");
			sl.add(s);
			RESULT = sl;
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> stmt_list");
			RESULT = new InsnList();
		:}
;

stmt
	::= stmt_if_maybe_else
		{:
			Parser.l.log(Level.INFO, "stmt_if_maybe_else -> stmt");
		:}
	| stmt_while
		{:
			Parser.l.log(Level.INFO, "stmt_while -> stmt");
		:}
	| stmt_def_maybe_assign
		{:
			Parser.l.log(Level.INFO, "stmt_def_maybe_assign -> stmt");
		:}
	| stmt_assign
		{:
			Parser.l.log(Level.INFO, "assign -> stmt");
		:}
	| stmt_io:s
		{:
			RESULT = s;
			Parser.l.log(Level.INFO, "stmt_io -> stmt");
		:}
	| stmt_exit
		{:
			Parser.l.log(Level.INFO, "stmt_exit -> stmt");
		:}
	| stmt_method_call EOL
		{:
			Parser.l.log(Level.INFO, "stmt_method_call EOL -> stmt");
		:}
;

stmt_if_maybe_else
	::= stmt_if
		{:
			Parser.l.log(Level.INFO, "stmt_if -> stmt_if_maybe_else");
		:}
	| stmt_if ELSE block
		{:
			Parser.l.log(Level.INFO, "stmt_if ELSE block -> stmt_if_maybe_else");
		:}
;

stmt_if
	::= IF SP expr_bool block
		{:
			Parser.l.log(Level.INFO, "IF SP expr_bool block -> stmt_if");
		:}
;

stmt_while
	::= WHILE SP expr_bool block
		{:
			Parser.l.log(Level.INFO, "WHILE expr_bool block -> stmt_while");
		:}
;

stmt_exit
	::= RET EOL
		{:
			Parser.l.log(Level.INFO, "RET EOL -> stmt_exit");
		:}
	| RET SP expr EOL
		{:
			Parser.l.log(Level.INFO, "RET SP expr EOL -> stmt_exit");
		:}
;

stmt_def_maybe_assign
	::= TYPE ASSIGN_TYPE VAR_NAME EOL
		{:
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE VAR_NAME EOL -> stmt_def_maybe_assign");
		:}
	| TYPE ASSIGN_TYPE stmt_assign
		{:
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE stmt_assign -> stmt_def_maybe_assign");
		:}
;

stmt_method_call
	::= VAR_NAME LPAREN method_argument_list RPAREN
		{:
			Parser.l.log(Level.INFO, "VAR_NAME LPAREN method_argument_list RPAREN -> stmt_method_call");
		:}
;

method_argument_list
	::= method_argument_list method_argument
		{:
			Parser.l.log(Level.INFO, "method_argument_list method_argument -> method_argument_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> method_argument_list");
		:}
;

method_argument
	::= expr COMMA SP
		{:
			Parser.l.log(Level.INFO, "expr COMMA SP -> method_argument");
		:}
	| expr
		{:
			Parser.l.log(Level.INFO, "expr -> method_argument");
		:}
;

// TODO: ARRAY

stmt_assign
	::= VAR_NAME SP ASSIGN SP expr EOL
		{:
			Parser.l.log(Level.INFO, "VAR_NAME SP ASSIGN SP expr EOL -> stmt_assign");
		:}
;

stmt_io
	::= READ_LINE LPAREN VAR_NAME RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "READ_LINE SP VAR_NAME EOL -> stmt_io");
		:}
	| WRITE_LINE LPAREN expr:e RPAREN EOL
		{:
			RESULT = FunctionFactory.writeLine(e);
			Parser.l.log(Level.INFO, "WRITE_LINE SP expr EOL -> stmt_io");
		:}
	| WRITE LPAREN expr RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "WRITE SP expr EOL -> stmt_io");
		:}
;

expr
	::= expr_bool:e
		{:
			RESULT = e;
			Parser.l.log(Level.INFO, "expr_bool -> expr");
		:}
	| expr_int:e
		{:
			RESULT = e;
			Parser.l.log(Level.INFO, "expr_int -> expr");
		:}
	| expr_str:e
		{:
			RESULT = e;
			Parser.l.log(Level.INFO, "expr_str -> expr");
		:}
	| VAR_NAME
		{:
			// TODO;
			Parser.l.log(Level.INFO, "VAR_NAME -> expr");
		:}
	| stmt_method_call
		{:
			// TODO;
			Parser.l.log(Level.INFO, "stmt_method_call -> expr");
		:}
;

// TODO PREFIX BOOL CONDITIONS
expr_bool
	::= LIT_BOOL:lb
		{:
			RESULT = ExprFactory.create(lb);
			Parser.l.log(Level.INFO, "LIT_BOOL -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP expr_int SP expr_int
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP expr_bool SP expr_int -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP VAR_NAME SP expr_int
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP VAR_NAME SP expr_int -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP expr_int SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP expr_int SP VAR_NAME -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| BOOLEAN_OPERATOR SP VAR_NAME SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOLEAN_OPERATOR SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_OPERATOR SP expr_bool SP expr_bool
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP expr_bool SP expr_bool -> expr_bool");
		:}
	| LOGIC_OPERATOR SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_OPERATOR SP VAR_NAME SP expr_bool
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP VAR_NAME SP expr_bool -> expr_bool");
		:}
	| LOGIC_OPERATOR SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_OPERATOR SP expr_bool SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_OPERATOR SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_OPERATOR SP VAR_NAME SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_OPERATOR SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| UNARY_LOGIC_OPERATOR expr_bool
		{:
			Parser.l.log(Level.INFO, "UNARY_LOGIC_OPERATOR expr_int -> expr_bool");
		:}
	| UNARY_LOGIC_OPERATOR stmt_method_call
		{:
			Parser.l.log(Level.INFO, "UNARY_LOGIC_OPERATOR stmt_method_call -> expr_bool");
		:}
	| UNARY_LOGIC_OPERATOR VAR_NAME
		{:
			Parser.l.log(Level.INFO, "UNARY_LOGIC_OPERATOR VAR_NAME -> expr_bool");
		:}
;

expr_int
	::= LIT_INT:li
		{:
			RESULT = ExprFactory.create(li);
			Parser.l.log(Level.INFO, "LIT_INT -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP expr_int SP expr_int
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP expr_int SP expr_int -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP stmt_method_call SP stmt_method_call -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP VAR_NAME SP expr_int
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP VAR_NAME SP expr_int -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP VAR_NAME SP stmt_method_call -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP expr_int SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP expr_int SP VAR_NAME -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP stmt_method_call SP VAR_NAME -> expr_int");
		:}
	| ARITHMETIC_OPERATOR SP VAR_NAME SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP VAR_NAME SP VAR_NAME -> expr_int");
		:}
    | ARITHMETIC_OPERATOR SP LIT_INT:li1 SP LIT_INT:li2
        {:
            Parser.l.log(Level.INFO, "ARITHMETIC_OPERATOR SP LIT_INT SP LIT_INT -> expr_int");
        :}
;

expr_str
	::= LIT_STR:ls
		{:
			RESULT = ExprFactory.create(ls);
			Parser.l.log(Level.INFO, "LIT_STR -> expr_str");
		:}
;

block
	::= EOL INDENT stmt_list DEDENT
		{:
			Parser.l.log(Level.INFO, "EOL INDENT stmt_list DEDENT -> block");
		:}
;