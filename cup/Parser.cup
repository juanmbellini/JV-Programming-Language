package atlc;

import java_cup.runtime.*;
import atlc.nodes.*;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.commons.Method;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import org.objectweb.asm.Type;
import java.util.List;
import java.util.ArrayList;
import java.util.function.Function;
import java.util.function.Consumer;
import org.objectweb.asm.Type;
import atlc.expr.*;

parser code {:
	public static final Logger l = Logger.getLogger("PARSER");
	protected Context context;
	protected ArithmeticFactory arithmeticFactory = new ArithmeticFactory();
	protected LogicalFactory logicalFactory = new LogicalFactory();
	protected StrExprFactory strExprFactory = new StrExprFactory();

	public Parser(Scanner scanner, SymbolFactory factory, ClassWriter classWriter) {
		this(scanner, factory);
		this.context = new Context(classWriter);
	}

	public void syntax_error(Symbol s) {
		System.err.println("Syntax error at " + s);
	}
:}

terminal FUNC, RET; // Functions
terminal SP, INDENT, DEDENT, EOL; // Whitespace
terminal Type TYPE;
terminal String VAR_NAME;
terminal READ_LINE, WRITE_LINE, WRITE; // IO
terminal LPAREN, RPAREN, COMMA;

// Literals
terminal Integer LIT_INT;
terminal Boolean LIT_BOOL;
terminal String  LIT_STR;

terminal IF, ELSE;
terminal DO, WHILE;

terminal int MATH_BINOP;
terminal int BOOL_BINOP;
terminal int LOGIC_BINOP;
terminal int LOGIC_UNOP;
terminal ASSIGN;
terminal Type ASSIGN_TYPE;

non terminal program;
non terminal List<MethodNode> method_list;
non terminal MethodNode method;
non terminal param_list;
non terminal Consumer<Context> stmt_list;
non terminal Consumer<Context> stmt;
non terminal method_argument;
non terminal Consumer<Context> stmt_def_maybe_assign;
non terminal Consumer<Context> stmt_assign;
non terminal Consumer<Context> stmt_if_maybe_else;
non terminal Consumer<Context> stmt_if;
non terminal Consumer<Context> stmt_while;
non terminal Consumer<Context> stmt_io;
non terminal Consumer<Context> stmt_exit;
non terminal Consumer<Context> stmt_method_call;
non terminal Function<Context, Type> expr;
non terminal Function<Context, Type> expr_bool;
non terminal Function<Context, Type> expr_int;
non terminal Function<Context, Type> expr_str;
non terminal method_argument_list;
non terminal block;

precedence left ELSE;
precedence left SP; // TODO: CHECK IF OK
precedence left LPAREN;


// ESTRUCTURA
start with program;

program
	::= method_list:ml stmt_list:sl
		{:
		    sl.accept(context);
            context.endMethod();
			context.getCw().visitEnd();
			Parser.l.log(Level.INFO, "stmt_list -> PARSE COMPLETE!");
		:}
;

method_list
	::= method:m method_list:ml
		{:
			ml.add(m);
			RESULT = ml;
			Parser.l.log(Level.INFO, "method method_list -> method_list");
		:}
	| // empty
		{:
			context.start(Method.getMethod("void main (String[])"));
			Parser.l.log(Level.INFO, "lambda -> method_list");
		:}
;

method
	::= FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list block
		{:
			Parser.l.log(Level.INFO, "FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list block -> method");
		:}
	| FUNC SP VAR_NAME param_list block
		{:
			Parser.l.log(Level.INFO, "FUNC SP VAR_NAME param_list block -> method");
		:}
;

param_list
	::= SP TYPE ASSIGN_TYPE VAR_NAME param_list
		{:
			Parser.l.log(Level.INFO, "SP TYPE ASSIGN_TYPE VAR_NAME param_list -> param_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> param_list");
		:}
;

stmt_list
	::= stmt:s stmt_list:sl
		{:
			Parser.l.log(Level.INFO, "stmt stmt_list -> stmt_list ");
			if (s != null) {
			    RESULT = s.andThen(sl);
			}
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> stmt_list");
			RESULT = context -> {};
		:}
;

stmt
	::= stmt_if_maybe_else:s
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "stmt_if_maybe_else -> stmt");
		:}
	| stmt_while:s
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "stmt_while -> stmt");
		:}
	| stmt_def_maybe_assign:s
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "stmt_def_maybe_assign -> stmt");
		:}
	| stmt_assign:s
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "assign -> stmt");
		:}
	| stmt_io:s
		{:
			RESULT = s;
			Parser.l.log(Level.INFO, "stmt_io -> stmt");
		:}
	| stmt_exit:s
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "stmt_exit -> stmt");
		:}
	| stmt_method_call:s EOL
		{:
		    RESULT = s;
			Parser.l.log(Level.INFO, "stmt_method_call EOL -> stmt");
		:}
;

stmt_if_maybe_else
	::= stmt_if
		{:
			Parser.l.log(Level.INFO, "stmt_if -> stmt_if_maybe_else");
		:}
	| stmt_if ELSE block
		{:
			Parser.l.log(Level.INFO, "stmt_if ELSE block -> stmt_if_maybe_else");
		:}
;

stmt_if
	::= IF SP expr_bool block
		{:
			Parser.l.log(Level.INFO, "IF SP expr_bool block -> stmt_if");
		:}
;

stmt_while
	::= WHILE SP expr_bool block
		{:
			Parser.l.log(Level.INFO, "WHILE expr_bool block -> stmt_while");
		:}
;

stmt_exit
	::= RET EOL
		{:
			Parser.l.log(Level.INFO, "RET EOL -> stmt_exit");
		:}
	| RET SP expr EOL
		{:
			Parser.l.log(Level.INFO, "RET SP expr EOL -> stmt_exit");
		:}
;

stmt_def_maybe_assign
	::= TYPE:type ASSIGN_TYPE VAR_NAME:name EOL
		{:
		    RESULT = context -> context.addLocal(name, type);
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE VAR_NAME EOL -> stmt_def_maybe_assign");
		:}
	| TYPE:type ASSIGN_TYPE VAR_NAME:name SP ASSIGN SP expr:value EOL
		{:
			RESULT = context -> context.addLocal(name, type, value);
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE stmt_assign -> stmt_def_maybe_assign");
		:}
;

stmt_method_call
	::= VAR_NAME LPAREN method_argument_list RPAREN
		{:
			Parser.l.log(Level.INFO, "VAR_NAME LPAREN method_argument_list RPAREN -> stmt_method_call");
		:}
;

method_argument_list
	::= method_argument_list method_argument
		{:
			Parser.l.log(Level.INFO, "method_argument_list method_argument -> method_argument_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> method_argument_list");
		:}
;

method_argument
	::= expr COMMA SP
		{:
			Parser.l.log(Level.INFO, "expr COMMA SP -> method_argument");
		:}
	| expr
		{:
			Parser.l.log(Level.INFO, "expr -> method_argument");
		:}
;

// TODO: ARRAY

stmt_assign
	::= VAR_NAME:name SP ASSIGN SP expr:value EOL
		{:
			Parser.l.log(Level.INFO, "VAR_NAME SP ASSIGN SP expr EOL -> stmt_assign");
		:}
;

stmt_io
	::= READ_LINE LPAREN VAR_NAME RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "READ_LINE SP VAR_NAME EOL -> stmt_io");
		:}
	| WRITE_LINE LPAREN expr:e RPAREN EOL
		{:
			RESULT = context -> FunctionFactory.writeLine(e, context);
			Parser.l.log(Level.INFO, "WRITE_LINE SP expr EOL -> stmt_io");
		:}
	| WRITE LPAREN expr RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "WRITE SP expr EOL -> stmt_io");
		:}
;

expr
	::= expr_bool:e
		{:
		    RESULT = e;
			Parser.l.log(Level.INFO, "expr_bool -> expr");
		:}
	| expr_int:e
		{:
		    RESULT = e;
			Parser.l.log(Level.INFO, "expr_int -> expr");
		:}
	| expr_str:e
		{:
		    RESULT = e;
			Parser.l.log(Level.INFO, "expr_str -> expr");
		:}
	| VAR_NAME:name
		{:
			RESULT = context -> {
			    int id = context.getVariableId(name);
                context.getGa().loadLocal(id);
                return context.getVariableType(id);
			};
			Parser.l.log(Level.INFO, "VAR_NAME -> expr");
		:}
	| stmt_method_call
		{:
			// TODO;
			Parser.l.log(Level.INFO, "stmt_method_call -> expr");
		:}
;

// TODO PREFIX BOOL CONDITIONS
expr_bool
	::= LIT_BOOL:lb
		{:
			RESULT = logicalFactory.createLiteral(lb);
			Parser.l.log(Level.INFO, "LIT_BOOL -> expr_bool");
		:}
	| BOOL_BINOP:op SP expr_int:e1 SP expr_int:e2
		{:
		    RESULT = logicalFactory.createBinary(op, e1, e2);
			Parser.l.log(Level.INFO, "BOOL_BINOP SP expr_bool SP expr_int -> expr_bool");
		:}
	| BOOL_BINOP SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| BOOL_BINOP SP VAR_NAME SP expr_int
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP expr_int -> expr_bool");
		:}
	| BOOL_BINOP SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| BOOL_BINOP SP expr_int SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP expr_int SP VAR_NAME -> expr_bool");
		:}
	| BOOL_BINOP SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| BOOL_BINOP SP VAR_NAME SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_BINOP:op SP expr_bool:e1 SP expr_bool:e2
		{:
		    RESULT = logicalFactory.createBinary(op, e1, e2);
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP expr_bool SP expr_bool -> expr_bool");
		:}
	| LOGIC_BINOP SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_BINOP SP VAR_NAME SP expr_bool
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP expr_bool -> expr_bool");
		:}
	| LOGIC_BINOP SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_BINOP SP expr_bool SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_BINOP SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_BINOP SP VAR_NAME SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_UNOP expr_bool
		{:
			Parser.l.log(Level.INFO, "LOGIC_UNOP expr_int -> expr_bool");
		:}
	| LOGIC_UNOP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_UNOP stmt_method_call -> expr_bool");
		:}
	| LOGIC_UNOP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_UNOP VAR_NAME -> expr_bool");
		:}
;

expr_int
	::= LIT_INT:li
		{:
			RESULT = arithmeticFactory.createLiteral(li);
			Parser.l.log(Level.INFO, "LIT_INT -> expr_int");
		:}
	| MATH_BINOP:op SP expr_int:e1 SP expr_int:e2
		{:
		    RESULT = arithmeticFactory.createBinary(op, e1, e2);
			Parser.l.log(Level.INFO, "MATH_BINOP SP expr_int SP expr_int -> expr_int");
		:}
	| MATH_BINOP:op SP stmt_method_call SP stmt_method_call
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP stmt_method_call SP stmt_method_call -> expr_int");
		:}
	| MATH_BINOP:op SP VAR_NAME SP expr_int
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP expr_int -> expr_int");
		:}
	| MATH_BINOP:op SP VAR_NAME SP stmt_method_call
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP stmt_method_call -> expr_int");
		:}
	| MATH_BINOP:op SP expr_int SP VAR_NAME
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP expr_int SP VAR_NAME -> expr_int");
		:}
	| MATH_BINOP:op SP stmt_method_call SP VAR_NAME
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP stmt_method_call SP VAR_NAME -> expr_int");
		:}
	| MATH_BINOP:op SP VAR_NAME SP VAR_NAME
		{:
		    // TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP VAR_NAME -> expr_int");
		:}
;

expr_str
	::= LIT_STR:ls
		{:
			RESULT = strExprFactory.createLiteral(ls);
			Parser.l.log(Level.INFO, "LIT_STR -> expr_str");
		:}
;

block
	::= EOL INDENT stmt_list DEDENT
		{:
			Parser.l.log(Level.INFO, "EOL INDENT stmt_list DEDENT -> block");
		:}
;
