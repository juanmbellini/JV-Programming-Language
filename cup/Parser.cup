package atlc;

import java_cup.runtime.*;
import atlc.nodes.*;
import atlc.expr.*;
import atlc.var.*;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.commons.Method;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;
import java.util.logging.Logger;
import java.util.logging.Level;
import org.objectweb.asm.Type;
import java.util.List;
import java.util.ArrayList;
import java.util.function.Function;
import java.util.function.Consumer;
import org.objectweb.asm.Type;

parser code {:
	public static final Logger l = Logger.getLogger("PARSER");
	protected Context context;
	protected ArithmeticFactory arithmeticFactory = new ArithmeticFactory();
	protected LogicalFactory logicalFactory = new LogicalFactory();
	protected StrExprFactory strExprFactory = new StrExprFactory();
	protected VariableFactory varFactory = new VariableFactory();

	public Parser(Scanner scanner, SymbolFactory factory, ClassWriter classWriter) {
		this(scanner, factory);
		this.context = new Context(classWriter);
	}

	public void syntax_error(Symbol s) {
		System.err.println("Syntax error at " + s);
	}
:}

terminal FUNC, RET; // Functions
terminal SP, INDENT, DEDENT, EOL; // Whitespace
terminal Type TYPE;
terminal String VAR_NAME;
terminal READ_LINE, WRITE_LINE, WRITE; // IO
terminal LPAREN, RPAREN, COMMA;

// Literals
terminal Integer LIT_INT;
terminal Boolean LIT_BOOL;
terminal String  LIT_STR;

terminal IF, ELSE;
terminal DO, WHILE;

terminal int MATH_BINOP;
terminal int BOOL_BINOP;
terminal int LOGIC_BINOP;
terminal LOGIC_UNOP_NOT;
terminal ASSIGN;
terminal Type ASSIGN_TYPE;

non terminal program;
//non terminal List<MethodNode> method_list;
//non terminal MethodNode method;
non terminal method_list;
non terminal method;
non terminal param_list;
non terminal Consumer<Context> stmt_list;
non terminal Consumer<Context> stmt;
non terminal method_argument;
non terminal Consumer<Context> stmt_def_maybe_assign;
non terminal Consumer<Context> stmt_assign;
non terminal Consumer<Context> stmt_if_maybe_else;
non terminal Consumer<Context> stmt_while;
non terminal Consumer<Context> stmt_io;
non terminal Consumer<Context> stmt_return;
non terminal Consumer<Context> stmt_method_call;
non terminal Function<Context, Type> expr;
non terminal Function<Context, Type> expr_bool;
non terminal Function<Context, Type> expr_int;
non terminal Function<Context, Type> expr_str;
non terminal method_argument_list;
non terminal Consumer<Context> closure;

precedence left ELSE;
precedence left SP; // TODO: CHECK IF OK
precedence left LPAREN;


// ESTRUCTURA
start with program;

program
	::= method_list:ml stmt_list:sl
		{:
			Parser.l.log(Level.INFO, "stmt_list -> PARSE COMPLETE!");
			sl.accept(context);
			context.endMethod();
			context.getCw().visitEnd();
		:}
;

method_list
	::= method:m method_list:ml
		{:
			Parser.l.log(Level.INFO, "method method_list -> method_list");
//			ml.add(m);
//			RESULT = ml;
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> method_list");
			context.start(Method.getMethod("void main (String[])"));
		:}
;

method
	::= FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list closure
		{:
			Parser.l.log(Level.INFO, "FUNC ASSIGN_TYPE TYPE SP VAR_NAME param_list closure -> method");
		:}
	| FUNC SP VAR_NAME param_list closure
		{:
			Parser.l.log(Level.INFO, "FUNC SP VAR_NAME param_list closure -> method");
		:}
;

param_list
	::= SP TYPE ASSIGN_TYPE VAR_NAME param_list
		{:
			Parser.l.log(Level.INFO, "SP TYPE ASSIGN_TYPE VAR_NAME param_list -> param_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> param_list");
		:}
;

stmt_list
	::= stmt:s stmt_list:sl
		{:
			Parser.l.log(Level.INFO, "stmt stmt_list -> stmt_list ");
			if (s != null) {
				RESULT = s.andThen(sl);
			} else {
				// TODO: REMOVE s!=null and THIS.
				s = context -> {};
				RESULT = s.andThen(sl);
			}
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> stmt_list");
			RESULT = context -> {};
		:}
;

stmt
	::= stmt_if_maybe_else:s
		{:
			Parser.l.log(Level.INFO, "stmt_if_maybe_else -> stmt");
			RESULT = s;
		:}
	| stmt_while:s
		{:
			Parser.l.log(Level.INFO, "stmt_while -> stmt");
			RESULT = s;
		:}
	| stmt_def_maybe_assign:s
		{:
			Parser.l.log(Level.INFO, "stmt_def_maybe_assign -> stmt");
			RESULT = s;
		:}
	| stmt_assign:s
		{:
			Parser.l.log(Level.INFO, "stmt_assign -> stmt");
			RESULT = s;
		:}
	| stmt_io:s
		{:
			Parser.l.log(Level.INFO, "stmt_io -> stmt");
			RESULT = s;
		:}
	| stmt_return:s
		{:
			Parser.l.log(Level.INFO, "stmt_return -> stmt");
			RESULT = s;
		:}
	| stmt_method_call:s EOL
		{:
			Parser.l.log(Level.INFO, "stmt_method_call EOL -> stmt");
			RESULT = s;
		:}
;

stmt_if_maybe_else
	::= IF SP expr_bool:expr closure:cl
		{:
			Parser.l.log(Level.INFO, "IF SP expr_bool closure -> stmt_if_maybe_else");
			RESULT = FlowControlFactory.createIf(expr, cl, null);
		:}
	| IF SP expr_bool:expr closure:cl ELSE closure:ecl
		{:
			Parser.l.log(Level.INFO, "IF SP expr_bool closure ELSE closure -> stmt_if_maybe_else");
			RESULT = FlowControlFactory.createIf(expr, cl, ecl);
		:}
;

stmt_while
	::= WHILE SP expr_bool closure
		{:
			Parser.l.log(Level.INFO, "WHILE expr_bool closure -> stmt_while");
		:}
;

stmt_return
	::= RET EOL
		{:
			Parser.l.log(Level.INFO, "RET EOL -> stmt_return");
		:}
	| RET SP expr EOL
		{:
			Parser.l.log(Level.INFO, "RET SP expr EOL -> stmt_return");
		:}
;

stmt_def_maybe_assign
	::= TYPE:type ASSIGN_TYPE VAR_NAME:name EOL
		{:
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE VAR_NAME EOL -> stmt_def_maybe_assign");
			RESULT = varFactory.createLocal(name, type);
		:}
	| TYPE:type ASSIGN_TYPE VAR_NAME:name SP ASSIGN SP expr:value EOL
		{:
			Parser.l.log(Level.INFO, "TYPE ASSIGN_TYPE stmt_assign -> stmt_def_maybe_assign");
			RESULT = varFactory.createLocal(name, type, value);
		:}
;

stmt_method_call
	::= VAR_NAME LPAREN method_argument_list RPAREN
		{:
			Parser.l.log(Level.INFO, "VAR_NAME LPAREN method_argument_list RPAREN -> stmt_method_call");
		:}
;

method_argument_list
	::= method_argument_list method_argument
		{:
			Parser.l.log(Level.INFO, "method_argument_list method_argument -> method_argument_list");
		:}
	| // empty
		{:
			Parser.l.log(Level.INFO, "lambda -> method_argument_list");
		:}
;

method_argument
	::= expr COMMA SP
		{:
			Parser.l.log(Level.INFO, "expr COMMA SP -> method_argument");
		:}
	| expr
		{:
			Parser.l.log(Level.INFO, "expr -> method_argument");
		:}
;

// TODO: ARRAY

stmt_assign
	::= VAR_NAME:name SP ASSIGN SP expr:value EOL
		{:
			Parser.l.log(Level.INFO, "VAR_NAME SP ASSIGN SP expr EOL -> stmt_assign");
			RESULT = varFactory.assignLocal(name, value);
		:}
;

stmt_io
	::= READ_LINE LPAREN VAR_NAME RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "READ_LINE SP VAR_NAME EOL -> stmt_io");
		:}
	| WRITE_LINE LPAREN expr:e RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "WRITE_LINE SP expr EOL -> stmt_io");
			RESULT = context -> FunctionFactory.writeLine(e, context);
		:}
	| WRITE LPAREN expr:e RPAREN EOL
		{:
			Parser.l.log(Level.INFO, "WRITE SP expr EOL -> stmt_io");
			RESULT = context -> FunctionFactory.write(e, context);
		:}
;

expr
	::= expr_bool:e
		{:
			Parser.l.log(Level.INFO, "expr_bool -> expr");
			RESULT = e;
		:}
	| expr_int:e
		{:
			Parser.l.log(Level.INFO, "expr_int -> expr");
			RESULT = e;
		:}
	| expr_str:e
		{:
			Parser.l.log(Level.INFO, "expr_str -> expr");
			RESULT = e;
		:}
	| VAR_NAME:name
		{:
			Parser.l.log(Level.INFO, "VAR_NAME -> expr");
			RESULT = varFactory.loadLocal(name);
		:}
	| stmt_method_call
		{:
			// TODO;
			Parser.l.log(Level.INFO, "stmt_method_call -> expr");
		:}
;

// TODO PREFIX BOOL CONDITIONS
expr_bool
	::= LIT_BOOL:lb
		{:
			Parser.l.log(Level.INFO, "LIT_BOOL -> expr_bool");
			RESULT = logicalFactory.createLiteral(lb);
		:}
	| BOOL_BINOP:op SP expr_int:e1 SP expr_int:e2
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP expr_bool SP expr_int -> expr_bool");
			RESULT = logicalFactory.createBinary(op, e1, e2);
		:}
	| BOOL_BINOP SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| BOOL_BINOP:op SP VAR_NAME:v1 SP expr_int:e1
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP expr_int -> expr_bool");
			RESULT = logicalFactory.createBinary(op, varFactory.loadLocal(v1), e1);
		:}
	| BOOL_BINOP SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| BOOL_BINOP:op SP expr_int:e1 SP VAR_NAME:v1
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP expr_int SP VAR_NAME -> expr_bool");
			RESULT = logicalFactory.createBinary(op, e1, varFactory.loadLocal(v1));
		:}
	| BOOL_BINOP SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| BOOL_BINOP:op SP VAR_NAME:v1 SP VAR_NAME:v2
		{:
			Parser.l.log(Level.INFO, "BOOL_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
			RESULT = logicalFactory.createBinary(op, varFactory.loadLocal(v1), varFactory.loadLocal(v2));
		:}
	| LOGIC_BINOP:op SP expr_bool:e1 SP expr_bool:e2
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP expr_bool SP expr_bool -> expr_bool");
			RESULT = arithmeticFactory.createBinary(op, e1, e2);
		:}
	| LOGIC_BINOP SP stmt_method_call SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP stmt_method_call SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_BINOP:op SP VAR_NAME:v1 SP expr_bool:e1
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP expr_bool -> expr_bool");
			RESULT = arithmeticFactory.createBinary(op, varFactory.loadLocal(v1), e1);
		:}
	| LOGIC_BINOP SP VAR_NAME SP stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP stmt_method_call -> expr_bool");
		:}
	| LOGIC_BINOP:op SP expr_bool:e1 SP VAR_NAME:v1
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
			RESULT = arithmeticFactory.createBinary(op, e1, varFactory.loadLocal(v1));
		:}
	| LOGIC_BINOP SP stmt_method_call SP VAR_NAME
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP stmt_method_call SP VAR_NAME -> expr_bool");
		:}
	| LOGIC_BINOP:op SP VAR_NAME:v1 SP VAR_NAME:v2
		{:
			Parser.l.log(Level.INFO, "LOGIC_BINOP SP VAR_NAME SP VAR_NAME -> expr_bool");
			RESULT = arithmeticFactory.createBinary(op, varFactory.loadLocal(v1), varFactory.loadLocal(v2));
		:}
	| LOGIC_UNOP_NOT:op expr_bool:e
		{:
			Parser.l.log(Level.INFO, "LOGILOGIC_UNOP_NOT_UNOP expr_int -> expr_bool");
			RESULT = logicalFactory.createNot(e);
		:}
	| LOGIC_UNOP_NOT stmt_method_call
		{:
			Parser.l.log(Level.INFO, "LOGILOGIC_UNOP_NOT_UNOP stmt_method_call -> expr_bool");
		:}
	| LOGIC_UNOP_NOT VAR_NAME:v1
		{:
			Parser.l.log(Level.INFO, "LOGICLOGIC_UNOP_NOTUNOP VAR_NAME -> expr_bool");
			RESULT = logicalFactory.createNot(varFactory.loadLocal(v1));
		:}
;

expr_int
	::= LIT_INT:li
		{:
			Parser.l.log(Level.INFO, "LIT_INT -> expr_int");
			RESULT = arithmeticFactory.createLiteral(li);
		:}
	| MATH_BINOP:op SP expr_int:e1 SP expr_int:e2
		{:
			Parser.l.log(Level.INFO, "MATH_BINOP SP expr_int SP expr_int -> expr_int");
			RESULT = arithmeticFactory.createBinary(op, e1, e2);
		:}
	| MATH_BINOP:op SP stmt_method_call SP stmt_method_call
		{:
			// TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP stmt_method_call SP stmt_method_call -> expr_int");
		:}
	| MATH_BINOP:op SP VAR_NAME:v1 SP expr_int:e1
		{:
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP expr_int -> expr_int");
			RESULT = arithmeticFactory.createBinary(op, varFactory.loadLocal(v1), e1);
		:}
	| MATH_BINOP:op SP VAR_NAME SP stmt_method_call
		{:
			// TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP stmt_method_call -> expr_int");
		:}
	| MATH_BINOP:op SP expr_int:e1 SP VAR_NAME:v1
		{:
			Parser.l.log(Level.INFO, "MATH_BINOP SP expr_int SP VAR_NAME -> expr_int");
			RESULT = arithmeticFactory.createBinary(op, e1, varFactory.loadLocal(v1));
		:}
	| MATH_BINOP:op SP stmt_method_call SP VAR_NAME
		{:
			// TODO
			Parser.l.log(Level.INFO, "MATH_BINOP SP stmt_method_call SP VAR_NAME -> expr_int");
		:}
	| MATH_BINOP:op SP VAR_NAME:v1 SP VAR_NAME:v2
		{:
			Parser.l.log(Level.INFO, "MATH_BINOP SP VAR_NAME SP VAR_NAME -> expr_int");
			RESULT = arithmeticFactory.createBinary(op, varFactory.loadLocal(v1), varFactory.loadLocal(v2));
		:}
;

expr_str
	::= LIT_STR:ls
		{:
			Parser.l.log(Level.INFO, "LIT_STR -> expr_str");
			RESULT = strExprFactory.createLiteral(ls);
		:}
;

closure
	::= EOL INDENT stmt_list:sl DEDENT
		{:
			Parser.l.log(Level.INFO, "EOL INDENT stmt_list DEDENT -> closure");
			// TODO manage closure stack
			RESULT = sl;
		:}
;
